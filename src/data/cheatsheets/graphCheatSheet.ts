import { CheatSheetItem, createCheatSheet } from '@/common/commonCheatSheet';

export const graphCheatSheet: CheatSheetItem[] = [
  createCheatSheet(
    'Creating an adjacency list',
    'graph = {\n    "A": ["B", "C"],\n    "B": ["A", "D", "E"],\n    "C": ["A", "F"],\n    "D": ["B"],\n    "E": ["B", "F"],\n    "F": ["C", "E"]\n}',
    'Initializes a graph using an adjacency list representation.',
    'create',
    'O(V + E)',
    'V is the number of vertices, E is the number of edges.',
  ),
  createCheatSheet(
    'Adding a vertex',
    'graph["G"] = []',
    'Adds a new vertex "G" to the graph with no edges.',
    'add',
    'O(1)',
    'N/A',
  ),
  createCheatSheet(
    'Adding an edge',
    'graph["A"].append("G")',
    'Adds a new edge from vertex "A" to vertex "G".',
    'add',
    'O(1)',
    'N/A',
  ),
  createCheatSheet(
    'Removing a vertex',
    'del graph["G"]\nfor vertex in graph:\n    if "G" in graph[vertex]:\n        graph[vertex].remove("G")',
    'Removes vertex "G" and all its associated edges from the graph.',
    'remove',
    'O(V + E)',
    'V is the number of vertices, E is the number of edges.',
  ),
  createCheatSheet(
    'Removing an edge',
    'graph["A"].remove("G")',
    'Removes the edge from vertex "A" to vertex "G".',
    'remove',
    'O(1)',
    'N/A',
  ),
  createCheatSheet(
    'Breadth-First Search (BFS)',
    'from collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    while queue:\n        vertex = queue.popleft()\n        if vertex not in visited:\n            print(vertex)\n            visited.add(vertex)\n            queue.extend(graph[vertex] - visited)',
    'Performs a BFS traversal starting from the given vertex.',
    'traversal',
    'O(V + E)',
    'V is the number of vertices, E is the number of edges.',
  ),
  createCheatSheet(
    'Depth-First Search (DFS)',
    'def dfs(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    print(start)\n    for next in graph[start] - visited:\n        dfs(graph, next, visited)\n    return visited',
    'Performs a DFS traversal starting from the given vertex.',
    'traversal',
    'O(V + E)',
    'V is the number of vertices, E is the number of edges.',
  ),
  createCheatSheet(
    'Finding the shortest path using BFS',
    'from collections import deque\n\ndef shortest_path(graph, start, end):\n    queue = deque([(start, [start])])\n    while queue:\n        (vertex, path) = queue.popleft()\n        for next in graph[vertex] - set(path):\n            if next == end:\n                return path + [next]\n            else:\n                queue.append((next, path + [next]))',
    'Finds the shortest path between two vertices using BFS.',
    'search',
    'O(V + E)',
    'V is the number of vertices, E is the number of edges.',
  ),
  createCheatSheet(
    'Detecting a cycle in an undirected graph',
    'def has_cycle(graph):\n    visited = set()\n    def dfs(vertex, parent):\n        visited.add(vertex)\n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                if dfs(neighbor, vertex):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n    for vertex in graph:\n        if vertex not in visited:\n            if dfs(vertex, -1):\n                return True\n    return False',
    'Detects if there is a cycle in an undirected graph.',
    'utility',
    'O(V + E)',
    'V is the number of vertices, E is the number of edges.',
  ),
  createCheatSheet(
    'Topological sort using DFS',
    'def topological_sort(graph):\n    visited = set()\n    stack = []\n    def dfs(vertex):\n        visited.add(vertex)\n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                dfs(neighbor)\n        stack.append(vertex)\n    for vertex in graph:\n        if vertex not in visited:\n            dfs(vertex)\n    return stack[::-1]',
    'Performs a topological sort on a directed acyclic graph (DAG) using DFS.',
    'sort',
    'O(V + E)',
    'V is the number of vertices, E is the number of edges.',
  ),
  createCheatSheet(
    "Dijkstra's algorithm for shortest path",
    'import heapq\n\ndef dijkstra(graph, start):\n    distances = {vertex: float("inf") for vertex in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        current_distance, current_vertex = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for neighbor, weight in graph[current_vertex].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances',
    "Finds the shortest path from a start vertex to all other vertices in a weighted graph using Dijkstra's algorithm.",
    'search',
    'O((V + E) log V)',
    'V is the number of vertices, E is the number of edges.',
  ),
  createCheatSheet(
    "Kruskal's algorithm for Minimum Spanning Tree (MST)",
    'def find(parent, i):\n    if parent[i] == i:\n        return i\n    return find(parent, parent[i])\n\ndef union(parent, rank, x, y):\n    root_x = find(parent, x)\n    root_y = find(parent, y)\n    if rank[root_x] > rank[root_y]:\n        parent[root_y] = root_x\n    elif rank[root_x] < rank[root_y]:\n        parent[root_x] = root_y\n    else:\n        parent[root_y] = root_x\n        rank[root_x] += 1\n\ndef kruskal(graph):\n    result = []\n    i, e = 0, 0\n    graph = sorted(graph, key=lambda item: item[2])\n    parent = {vertex: vertex for vertex in graph}\n    rank = {vertex: 0 for vertex in graph}\n    while e < len(graph) - 1:\n        u, v, w = graph[i]\n        i += 1\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            e += 1\n            result.append([u, v, w])\n            union(parent, rank, x, y)\n    return result',
    "Finds the Minimum Spanning Tree (MST) of a weighted undirected graph using Kruskal's algorithm.",
    'utility',
    'O(E log E)',
    'E is the number of edges.',
  ),
  createCheatSheet(
    "Prim's algorithm for Minimum Spanning Tree (MST)",
    'import heapq\n\ndef prim(graph, start):\n    mst = []\n    visited = set([start])\n    edges = [(weight, start, to) for to, weight in graph[start].items()]\n    heapq.heapify(edges)\n    while edges:\n        weight, frm, to = heapq.heappop(edges)\n        if to not in visited:\n            visited.add(to)\n            mst.append((frm, to, weight))\n            for to_next, weight in graph[to].items():\n                if to_next not in visited:\n                    heapq.heappush(edges, (weight, to, to_next))\n    return mst',
    "Finds the Minimum Spanning Tree (MST) of a weighted undirected graph using Prim's algorithm.",
    'utility',
    'O((V + E) log V)',
    'V is the number of vertices, E is the number of edges.',
  ),
  createCheatSheet(
    'Floyd-Warshall algorithm for all-pairs shortest paths',
    'def floyd_warshall(graph):\n    dist = {vertex: {vertex: float("inf") for vertex in graph} for vertex in graph}\n    for u in graph:\n        dist[u][u] = 0\n        for v, weight in graph[u].items():\n            dist[u][v] = weight\n    for k in graph:\n        for i in graph:\n            for j in graph:\n                if dist[i][j] > dist[i][k] + dist[k][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n    return dist',
    'Finds the shortest path between all pairs of vertices in a weighted graph using the Floyd-Warshall algorithm.',
    'search',
    'O(V^3)',
    'V is the number of vertices.',
  ),
  createCheatSheet(
    'Bellman-Ford algorithm for shortest path',
    'def bellman_ford(graph, start):\n    distances = {vertex: float("inf") for vertex in graph}\n    distances[start] = 0\n    for _ in range(len(graph) - 1):\n        for u in graph:\n            for v, weight in graph[u].items():\n                if distances[u] + weight < distances[v]:\n                    distances[v] = distances[u] + weight\n    for u in graph:\n        for v, weight in graph[u].items():\n            if distances[u] + weight < distances[v]:\n                raise ValueError("Graph contains a negative-weight cycle")\n    return distances',
    'Finds the shortest path from a start vertex to all other vertices in a weighted graph using the Bellman-Ford algorithm.',
    'search',
    'O(V * E)',
    'V is the number of vertices, E is the number of edges.',
  ),
];
