import { CheatSheetItem, createCheatSheet } from '@/common/commonCheatSheet';

export const treeCheatSheet: CheatSheetItem[] = [
  createCheatSheet(
    'Creating a binary tree node',
    'class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right',
    'Defines a class for a binary tree node with a value, left child, and right child.',
    'create',
    'O(1)',
    'N/A',
  ),
  createCheatSheet(
    'Inserting a node in a binary search tree (BST)',
    'def insert(root, val):\n    if not root:\n        return TreeNode(val)\n    if val < root.val:\n        root.left = insert(root.left, val)\n    else:\n        root.right = insert(root.right, val)\n    return root',
    'Inserts a node with the given value into a BST.',
    'add',
    'O(log n) on average, O(n) in the worst case',
    'The worst case occurs in a skewed tree.',
  ),
  createCheatSheet(
    'Searching for a node in a BST',
    'def search(root, val):\n    if not root or root.val == val:\n        return root\n    if val < root.val:\n        return search(root.left, val)\n    return search(root.right, val)',
    'Searches for a node with the given value in a BST.',
    'search',
    'O(log n) on average, O(n) in the worst case',
    'The worst case occurs in a skewed tree.',
  ),
  createCheatSheet(
    'Deleting a node in a BST',
    'def delete(root, val):\n    if not root:\n        return root\n    if val < root.val:\n        root.left = delete(root.left, val)\n    elif val > root.val:\n        root.right = delete(root.right, val)\n    else:\n        if not root.left:\n            return root.right\n        elif not root.right:\n            return root.left\n        temp = find_min(root.right)\n        root.val = temp.val\n        root.right = delete(root.right, temp.val)\n    return root\n\ndef find_min(node):\n    while node.left:\n        node = node.left\n    return node',
    'Deletes a node with the given value from a BST.',
    'remove',
    'O(log n) on average, O(n) in the worst case',
    'The worst case occurs in a skewed tree.',
  ),
  createCheatSheet(
    'In-order traversal',
    'def in_order(root):\n    if root:\n        in_order(root.left)\n        print(root.val)\n        in_order(root.right)',
    'Performs an in-order traversal of the tree, printing the values in sorted order.',
    'traversal',
    'O(n)',
    'N/A',
  ),
  createCheatSheet(
    'Pre-order traversal',
    'def pre_order(root):\n    if root:\n        print(root.val)\n        pre_order(root.left)\n        pre_order(root.right)',
    'Performs a pre-order traversal of the tree, printing the root first, then the left subtree, and finally the right subtree.',
    'traversal',
    'O(n)',
    'N/A',
  ),
  createCheatSheet(
    'Post-order traversal',
    'def post_order(root):\n    if root:\n        post_order(root.left)\n        post_order(root.right)\n        print(root.val)',
    'Performs a post-order traversal of the tree, printing the left subtree first, then the right subtree, and finally the root.',
    'traversal',
    'O(n)',
    'N/A',
  ),
  createCheatSheet(
    'Level-order traversal (BFS)',
    'from collections import deque\n\ndef level_order(root):\n    if not root:\n        return\n    queue = deque([root])\n    while queue:\n        node = queue.popleft()\n        print(node.val)\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)',
    'Performs a level-order traversal of the tree using a queue (BFS).',
    'traversal',
    'O(n)',
    'N/A',
  ),
  createCheatSheet(
    'Finding the height of a tree',
    'def height(root):\n    if not root:\n        return 0\n    return 1 + max(height(root.left), height(root.right))',
    'Returns the height of the tree, which is the number of edges on the longest path from the root to a leaf.',
    'utility',
    'O(n)',
    'N/A',
  ),
  createCheatSheet(
    'Checking if a tree is balanced',
    'def is_balanced(root):\n    def check(root):\n        if not root:\n            return 0\n        left = check(root.left)\n        right = check(root.right)\n        if left == -1 or right == -1 or abs(left - right) > 1:\n            return -1\n        return 1 + max(left, right)\n    return check(root) != -1',
    'Checks if the tree is balanced, meaning the height difference between the left and right subtrees of any node is not more than 1.',
    'utility',
    'O(n)',
    'N/A',
  ),
  createCheatSheet(
    'Finding the lowest common ancestor (LCA) in a BST',
    'def lca(root, p, q):\n    while root:\n        if p.val < root.val > q.val:\n            root = root.left\n        elif p.val > root.val < q.val:\n            root = root.right\n        else:\n            return root',
    'Finds the lowest common ancestor of two nodes in a BST.',
    'search',
    'O(log n) on average, O(n) in the worst case',
    'The worst case occurs in a skewed tree.',
  ),
  createCheatSheet(
    'Finding the lowest common ancestor (LCA) in a binary tree',
    'def lca(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    left = lca(root.left, p, q)\n    right = lca(root.right, p, q)\n    return root if left and right else left or right',
    'Finds the lowest common ancestor of two nodes in a binary tree.',
    'search',
    'O(n)',
    'N/A',
  ),
  createCheatSheet(
    'Checking if a tree is a valid BST',
    'def is_valid_bst(root):\n    def in_order(node):\n        if not node:\n            return True\n        if not in_order(node.left):\n            return False\n        if node.val <= self.prev:\n            return False\n        self.prev = node.val\n        return in_order(node.right)\n    self.prev = float("-inf")\n    return in_order(root)',
    'Checks if the tree is a valid binary search tree (BST).',
    'utility',
    'O(n)',
    'N/A',
  ),
  createCheatSheet(
    'Finding the maximum path sum in a binary tree',
    'def max_path_sum(root):\n    def max_gain(node):\n        nonlocal max_sum\n        if not node:\n            return 0\n        left_gain = max(max_gain(node.left), 0)\n        right_gain = max(max_gain(node.right), 0)\n        price_newpath = node.val + left_gain + right_gain\n        max_sum = max(max_sum, price_newpath)\n        return node.val + max(left_gain, right_gain)\n    max_sum = float("-inf")\n    max_gain(root)\n    return max_sum',
    'Finds the maximum path sum in a binary tree, where a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections.',
    'utility',
    'O(n)',
    'N/A',
  ),
];
