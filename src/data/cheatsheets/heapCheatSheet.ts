import { CheatSheetItem, createCheatSheet } from '@/common/commonCheatSheet';

export const heapCheatSheet: CheatSheetItem[] = [
  createCheatSheet(
    'Creating a min-heap',
    'import heapq\nmin_heap = []\nheapq.heapify(min_heap)',
    'Initializes an empty min-heap using the `heapq` module.',
    'create',
    'O(n)',
    'N/A',
  ),
  createCheatSheet(
    'Creating a max-heap',
    'import heapq\nmax_heap = []\nheapq.heapify(max_heap)',
    'Initializes an empty max-heap using the `heapq` module. Note: `heapq` only provides min-heap by default, so you need to invert the values for a max-heap.',
    'create',
    'O(n)',
    'N/A',
  ),
  createCheatSheet(
    'Inserting an element into a min-heap',
    'heapq.heappush(min_heap, 5)',
    'Inserts the element 5 into the min-heap.',
    'add',
    'O(log n)',
    'N/A',
  ),
  createCheatSheet(
    'Inserting an element into a max-heap',
    'heapq.heappush(max_heap, -5)',
    'Inserts the element 5 into the max-heap by pushing its negative value.',
    'add',
    'O(log n)',
    'N/A',
  ),
  createCheatSheet(
    'Extracting the minimum element from a min-heap',
    'min_element = heapq.heappop(min_heap)',
    'Removes and returns the smallest element from the min-heap.',
    'remove',
    'O(log n)',
    'Popping from an empty heap will raise an IndexError.',
  ),
  createCheatSheet(
    'Extracting the maximum element from a max-heap',
    'max_element = -heapq.heappop(max_heap)',
    'Removes and returns the largest element from the max-heap by popping the negative of the smallest element.',
    'remove',
    'O(log n)',
    'Popping from an empty heap will raise an IndexError.',
  ),
  createCheatSheet(
    'Accessing the minimum element in a min-heap',
    'min_element = min_heap[0]',
    'Returns the smallest element in the min-heap without removing it.',
    'access',
    'O(1)',
    'Accessing an empty heap will raise an IndexError.',
  ),
  createCheatSheet(
    'Accessing the maximum element in a max-heap',
    'max_element = -max_heap[0]',
    'Returns the largest element in the max-heap without removing it by accessing the negative of the smallest element.',
    'access',
    'O(1)',
    'Accessing an empty heap will raise an IndexError.',
  ),
  createCheatSheet(
    'Merging two heaps',
    'heapq.merge(heap1, heap2)',
    'Returns an iterator over the elements of both heaps in sorted order.',
    'utility',
    'O(n + m)',
    'n and m are the number of elements in the two heaps.',
  ),
  createCheatSheet(
    'Heapifying a list',
    'heapq.heapify(my_list)',
    'Converts the list `my_list` into a min-heap in-place.',
    'create',
    'O(n)',
    'N/A',
  ),
  createCheatSheet(
    'Finding the n smallest elements',
    'smallest_elements = heapq.nsmallest(3, my_list)',
    'Returns the 3 smallest elements from the list `my_list`.',
    'utility',
    'O(n log k)',
    'k is the number of elements to find.',
  ),
  createCheatSheet(
    'Finding the n largest elements',
    'largest_elements = heapq.nlargest(3, my_list)',
    'Returns the 3 largest elements from the list `my_list`.',
    'utility',
    'O(n log k)',
    'k is the number of elements to find.',
  ),
  createCheatSheet(
    'Replacing the minimum element in a min-heap',
    'new_min_element = heapq.heapreplace(min_heap, 10)',
    'Removes the smallest element and inserts the element 10 into the min-heap.',
    'modify',
    'O(log n)',
    'N/A',
  ),
  createCheatSheet(
    'Replacing the maximum element in a max-heap',
    'new_max_element = -heapq.heapreplace(max_heap, -10)',
    'Removes the largest element and inserts the element 10 into the max-heap by replacing the negative of the smallest element.',
    'modify',
    'O(log n)',
    'N/A',
  ),
  createCheatSheet(
    'Pushing and popping from a min-heap',
    'new_min_element = heapq.heappushpop(min_heap, 10)',
    'Pushes the element 10 into the min-heap and then pops and returns the smallest element.',
    'modify',
    'O(log n)',
    'N/A',
  ),
  createCheatSheet(
    'Pushing and popping from a max-heap',
    'new_max_element = -heapq.heappushpop(max_heap, -10)',
    'Pushes the element 10 into the max-heap by pushing its negative value and then pops and returns the largest element by returning the negative of the smallest element.',
    'modify',
    'O(log n)',
    'N/A',
  ),
  createCheatSheet(
    'Checking if a list is a valid min-heap',
    'is_min_heap = all(my_list[i] >= my_list[(i - 1) // 2] for i in range(1, len(my_list)))',
    'Checks if the list `my_list` is a valid min-heap.',
    'utility',
    'O(n)',
    'N/A',
  ),
  createCheatSheet(
    'Checking if a list is a valid max-heap',
    'is_max_heap = all(my_list[i] <= my_list[(i - 1) // 2] for i in range(1, len(my_list)))',
    'Checks if the list `my_list` is a valid max-heap.',
    'utility',
    'O(n)',
    'N/A',
  ),
  createCheatSheet(
    'Sorting a list using a heap',
    'sorted_list = heapq.nsmallest(len(my_list), my_list)',
    'Sorts the list `my_list` using a heap.',
    'utility',
    'O(n log n)',
    'N/A',
  ),
  createCheatSheet(
    'Creating a priority queue',
    'import heapq\npriority_queue = []\nheapq.heappush(priority_queue, (priority, item))',
    'Creates a priority queue using a min-heap. The priority is the first element of the tuple.',
    'create',
    'O(log n)',
    'N/A',
  ),
  createCheatSheet(
    'Extracting the highest priority item from a priority queue',
    'priority, item = heapq.heappop(priority_queue)',
    'Removes and returns the item with the highest priority from the priority queue.',
    'remove',
    'O(log n)',
    'Popping from an empty priority queue will raise an IndexError.',
  ),
];
