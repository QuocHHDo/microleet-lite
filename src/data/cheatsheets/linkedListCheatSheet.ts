import { CheatSheetItem, createCheatSheet } from '@/common/commonCheatSheet';

export const linkedListCheatSheet: CheatSheetItem[] = [
  createCheatSheet(
    'Creating a linked list',
    'class Node:\n  def __init__(self, data):\n    self.data = data\n    self.next = None\n\nhead = Node(1)\nhead.next = Node(2)\nhead.next.next = Node(3)',
    'Defines a Node class and creates a linked list with elements 1, 2, and 3.',
    'create',
    'O(n)',
    'Creating a large linked list can be memory-intensive.',
  ),
  createCheatSheet(
    'Appending to the end of a linked list',
    'def append(head, data):\n  if not head:\n    return Node(data)\n  current = head\n  while current.next:\n    current = current.next\n  current.next = Node(data)\n  return head',
    'Adds a new node with the given data to the end of the linked list.',
    'add',
    'O(n)',
    'Appending to a large linked list can be slow.',
  ),
  createCheatSheet(
    'Inserting at the beginning of a linked list',
    'def insert_at_beginning(head, data):\n  new_node = Node(data)\n  new_node.next = head\n  return new_node',
    'Inserts a new node with the given data at the beginning of the linked list.',
    'add',
    'O(1)',
    'N/A',
  ),
  createCheatSheet(
    'Inserting at a specific position',
    'def insert_at_position(head, data, position):\n  if position == 0:\n    return insert_at_beginning(head, data)\n  new_node = Node(data)\n  current = head\n  for _ in range(position - 1):\n    if not current:\n      return head\n    current = current.next\n  new_node.next = current.next\n  current.next = new_node\n  return head',
    'Inserts a new node with the given data at the specified position in the linked list.',
    'add',
    'O(n)',
    'Inserting at a position beyond the length of the list will not insert the node.',
  ),
  createCheatSheet(
    'Removing the first node',
    'def remove_first(head):\n  if not head:\n    return None\n  return head.next',
    'Removes the first node from the linked list.',
    'remove',
    'O(1)',
    'Removing from an empty list will return None.',
  ),
  createCheatSheet(
    'Removing the last node',
    'def remove_last(head):\n  if not head or not head.next:\n    return None\n  current = head\n  while current.next.next:\n    current = current.next\n  current.next = None\n  return head',
    'Removes the last node from the linked list.',
    'remove',
    'O(n)',
    'Removing from a single-node list will return None.',
  ),
  createCheatSheet(
    'Removing a node at a specific position',
    'def remove_at_position(head, position):\n  if not head:\n    return None\n  if position == 0:\n    return head.next\n  current = head\n  for _ in range(position - 1):\n    if not current.next:\n      return head\n    current = current.next\n  if not current.next:\n    return head\n  current.next = current.next.next\n  return head',
    'Removes the node at the specified position in the linked list.',
    'remove',
    'O(n)',
    'Removing at a position beyond the length of the list will not remove any node.',
  ),
  createCheatSheet(
    'Accessing the first node',
    'head.data',
    'Accesses the data of the first node in the linked list.',
    'access',
    'O(1)',
    'Accessing from an empty list will raise an error.',
  ),
  createCheatSheet(
    'Accessing the last node',
    'def get_last(head):\n  if not head:\n    return None\n  current = head\n  while current.next:\n    current = current.next\n  return current.data',
    'Accesses the data of the last node in the linked list.',
    'access',
    'O(n)',
    'Accessing from an empty list will return None.',
  ),
  createCheatSheet(
    'Accessing a node at a specific position',
    'def get_at_position(head, position):\n  if not head:\n    return None\n  current = head\n  for _ in range(position):\n    if not current:\n      return None\n    current = current.next\n  return current.data if current else None',
    'Accesses the data of the node at the specified position in the linked list.',
    'access',
    'O(n)',
    'Accessing at a position beyond the length of the list will return None.',
  ),
  createCheatSheet(
    'Reversing a linked list',
    'def reverse_list(head):\n  prev = None\n  current = head\n  while current:\n    next_node = current.next\n    current.next = prev\n    prev = current\n    current = next_node\n  return prev',
    'Reverses the order of nodes in the linked list.',
    'modify',
    'O(n)',
    'Reversing a large linked list can be memory-intensive.',
  ),
  createCheatSheet(
    'Sorting a linked list',
    'def sort_list(head):\n  if not head or not head.next:\n    return head\n  def merge_sort(head):\n    if not head or not head.next:\n      return head\n    mid = get_middle(head)\n    next_to_mid = mid.next\n    mid.next = None\n    left = merge_sort(head)\n    right = merge_sort(next_to_mid)\n    return merge(left, right)\n  def merge(left, right):\n    dummy = Node(0)\n    current = dummy\n    while left and right:\n      if left.data < right.data:\n        current.next = left\n        left = left.next\n      else:\n        current.next = right\n        right = right.next\n      current = current.next\n    current.next = left if left else right\n    return dummy.next\n  def get_middle(head):\n    if not head:\n      return head\n    slow = head\n    fast = head\n    while fast.next and fast.next.next:\n      slow = slow.next\n      fast = fast.next.next\n    return slow\n  return merge_sort(head)',
    'Sorts the linked list in ascending order using merge sort.',
    'modify',
    'O(n log n)',
    'Sorting a large linked list can be memory-intensive.',
  ),
  createCheatSheet(
    'Finding the middle node',
    'def find_middle(head):\n  if not head:\n    return None\n  slow = head\n  fast = head\n  while fast and fast.next:\n    slow = slow.next\n    fast = fast.next.next\n  return slow.data',
    'Finds the middle node of the linked list.',
    'search',
    'O(n)',
    'Finding the middle of an empty list will return None.',
  ),
  createCheatSheet(
    'Checking for a cycle in the linked list',
    'def has_cycle(head):\n  if not head or not head.next:\n    return False\n  slow = head\n  fast = head.next\n  while slow != fast:\n    if not fast or not fast.next:\n      return False\n    slow = slow.next\n    fast = fast.next.next\n  return True',
    'Checks if the linked list contains a cycle.',
    'search',
    'O(n)',
    'Checking for a cycle in a large list can be slow.',
  ),
  createCheatSheet(
    'Length of a linked list',
    'def list_length(head):\n  length = 0\n  current = head\n  while current:\n    length += 1\n    current = current.next\n  return length',
    'Returns the number of nodes in the linked list.',
    'utility',
    'O(n)',
    'N/A',
  ),
  createCheatSheet(
    'Copy a linked list',
    'def copy_list(head):\n  if not head:\n    return None\n  new_head = Node(head.data)\n  current_old = head.next\n  current_new = new_head\n  while current_old:\n    current_new.next = Node(current_old.data)\n    current_new = current_new.next\n    current_old = current_old.next\n  return new_head',
    'Creates a shallow copy of the linked list.',
    'utility',
    'O(n)',
    'Copying a large linked list can be memory-intensive.',
  ),
];
