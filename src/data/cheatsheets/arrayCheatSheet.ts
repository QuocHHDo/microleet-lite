import {
  CheatSheetItem,
  createCheatSheet,
  OperationTypes,
} from '@/common/commonCheatSheet';

export const arrayCheatSheet: CheatSheetItem[] = [
  // CREATE
  createCheatSheet(
    'Creating a list',
    'my_list = [1, 2, 3]',
    'Initializes a list with the elements 1, 2, and 3.',
    OperationTypes.Create,
    'O(n)',
    'If the list is very large, memory usage can be significant.',
  ),
  createCheatSheet(
    'List comprehension',
    '[x for x in range(5)]',
    'Creates a list [0, 1, 2, 3, 4] using a concise syntax.',
    OperationTypes.Create,
    'O(n)',
    'Nested list comprehensions can be hard to read and maintain.',
  ),
  createCheatSheet(
    'Multidimensional arrays',
    'matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]',
    'Creates a 2D array (matrix).',
    OperationTypes.Create,
    'O(n * m)',
    'Deeply nested arrays can lead to performance issues.',
  ),

  // ADD
  createCheatSheet(
    'Appending to a list',
    'my_list.append(4)',
    'Adds the element 4 to the end of the list.',
    OperationTypes.Add,
    'O(1)',
    'Appending to a list with a large number of elements can cause memory reallocation.',
  ),
  createCheatSheet(
    'Inserting at a specific index',
    'my_list.insert(1, 99)',
    'Inserts the element 99 at index 1, shifting other elements to the right.',
    OperationTypes.Add,
    'O(n)',
    'Inserting at the beginning of a large list can be slow.',
  ),
  createCheatSheet(
    'Extending a list',
    'my_list.extend([5, 6])',
    'Adds the elements 5 and 6 to the end of the list in-place.',
    OperationTypes.Add,
    'O(k)',
    'Extending a list with a large number of elements can cause memory reallocation.',
  ),
  createCheatSheet(
    'Concatenate lists',
    'new_list = my_list + [7, 8]',
    'Returns a new list by concatenating my_list with [7, 8].',
    OperationTypes.Add,
    'O(n + m)',
    'Creating a new list can be memory-intensive for large lists.',
  ),

  // REMOVE
  createCheatSheet(
    'Removing an element by value',
    'my_list.remove(2)',
    'Removes the first occurrence of the element 2 from the list.',
    OperationTypes.Remove,
    'O(n)',
    'Removing an element from a large list can be slow.',
  ),
  createCheatSheet(
    'Popping an element',
    'my_list.pop()',
    'Removes and returns the last element of the list.',
    OperationTypes.Remove,
    'O(1)',
    'Popping from an empty list will raise an error.',
  ),
  createCheatSheet(
    'Popping an element at index',
    'my_list.pop(1)',
    'Removes and returns the element at index 1, shifting elements left.',
    OperationTypes.Remove,
    'O(n)',
    'Popping from an index out of bounds will raise an error.',
  ),
  createCheatSheet(
    'Clearing a list',
    'my_list.clear()',
    'Removes all elements from the list, making it empty.',
    OperationTypes.Remove,
    'O(1)',
    'Clearing a list does not free up memory immediately.',
  ),

  // ACCESS
  createCheatSheet(
    'Accessing elements',
    'my_list[0]',
    'Accesses the first element of the list (index starts at 0).',
    OperationTypes.Access,
    'O(1)',
    'Accessing an index out of bounds will raise an error.',
  ),
  createCheatSheet(
    'Slicing a list',
    'my_list[1:3]',
    'Returns a new list containing elements from index 1 to 2 (3 is excluded).',
    OperationTypes.Access,
    'O(k)',
    'Slicing a large list can be memory-intensive.',
  ),
  createCheatSheet(
    'Accessing elements in a 2D array',
    'matrix[1][2]',
    'Accesses the element at row 1, column 2 (returns 6).',
    OperationTypes.Access,
    'O(1)',
    'Accessing an index out of bounds will raise an error.',
  ),
  createCheatSheet(
    'Negative indexing',
    'element = my_list[-1]',
    'Accesses the last element of the list using negative indexing.',
    OperationTypes.Access,
    'O(1)',
    'Index out of range if the list is empty or the negative index is too large.',
  ),
  createCheatSheet(
    'Slicing with step',
    'my_list[0:5:2]',
    'Returns a new list of elements from index 0 to 4, stepping by 2.',
    OperationTypes.Access,
    'O(k)',
    'Stepping through a large list can be memory-intensive if the slice is large.',
  ),

  // MODIFY
  createCheatSheet(
    'Reversing a list',
    'my_list.reverse()',
    'Reverses the order of elements in-place.',
    OperationTypes.Modify,
    'O(n)',
    'Reversing a large list can be memory-intensive.',
  ),
  createCheatSheet(
    'Sorting a list in ascending order',
    'my_list.sort()',
    'Sorts the list in ascending order in-place.',
    OperationTypes.Modify,
    'O(n log n)',
    'Sorting a large list can be memory-intensive.',
  ),
  createCheatSheet(
    'Sorting a list in descending order',
    'my_list.sort(reverse=True)',
    'Sorts the list in descending order in-place.',
    OperationTypes.Modify,
    'O(n log n)',
    'Sorting a large list can be memory-intensive.',
  ),
  createCheatSheet(
    'Sorting with custom key',
    'my_list.sort(key=lambda x: some_function(x))',
    'Sorts using a custom function for comparison.',
    OperationTypes.Modify,
    'O(n log n)',
    'A complex key function can increase sorting overhead.',
  ),
  createCheatSheet(
    'Flattening a 2D array',
    '[item for sublist in matrix for item in sublist]',
    'Flattens a 2D array into a 1D list.',
    OperationTypes.Modify,
    'O(n * m)',
    'Flattening a large 2D array can be memory-intensive.',
  ),
  createCheatSheet(
    'Removing duplicates (via set)',
    'unique_list = list(set(my_list))',
    'Removes all duplicates but may lose original ordering.',
    OperationTypes.Modify,
    'O(n)',
    'Not suitable for nested or unhashable elements. Also changes order.',
  ),

  // SEARCH
  createCheatSheet(
    'Finding the index of an element',
    'my_list.index(3)',
    'Returns the index of the first occurrence of the element 3.',
    OperationTypes.Search,
    'O(n)',
    'Searching for an element not in the list will raise an error.',
  ),
  createCheatSheet(
    'Counting occurrences of an element',
    'my_list.count(3)',
    'Returns the number of times the element 3 appears in the list.',
    OperationTypes.Search,
    'O(n)',
    'Counting occurrences in a large list can be slow.',
  ),
  createCheatSheet(
    'Check if an element exists',
    '3 in my_list',
    'Returns True if the element 3 is in the list, otherwise False.',
    OperationTypes.Search,
    'O(n)',
    'Checking for an element in a large list can be slow.',
  ),

  // UTILITY
  createCheatSheet(
    'Length of a list',
    'len(my_list)',
    'Returns the number of elements in the list.',
    OperationTypes.Utility,
    'O(1)',
    'N/A',
  ),
  createCheatSheet(
    'Copy a list (shallow)',
    'new_list = my_list.copy()',
    'Creates a shallow copy of the list (1 level deep).',
    OperationTypes.Utility,
    'O(n)',
    'Nested objects are still referenced, so changes in nested lists reflect in both copies.',
  ),
  createCheatSheet(
    'Deep copy of a list',
    'import copy\nnew_list = copy.deepcopy(my_list)',
    'Recursively copies all nested objects, so changes in new_list do not affect my_list.',
    OperationTypes.Utility,
    'O(n)',
    'For deeply nested or large structures, deep copy can be slow and memory-intensive.',
  ),
];
